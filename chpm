#!/usr/bin/env python3
#
# 预设的环境变量:
#
# CHPM_TARGET_ARCH    目标编译架构
# CHPM_TARGET_PREFIX  目标安装位置
#
# CHPM_RECIPE_FILE    recipe 文件路径
# CHPM_RECIPE_DIR     recipe 文件目录路径
#
# CHPM_PKG_NAME       正在安装的包名
# CHPM_PKG_VERSION    正在安装的包版本
#
# CHPM_BUILD_DIR      临时构建目录
#

import os
import sys
import json
import shutil
import subprocess
import zipfile

from os import path
from pprint import pprint
from functools import partial
from dataclasses import dataclass, field
from argparse import ArgumentParser, Namespace
from typing import List, Dict, Optional, Any, Callable


print_dbg = partial(print, file=sys.stdout)
print_info = partial(print, file=sys.stdout)
print_err = partial(print, file=sys.stderr)


CHCORE_DIR = os.getcwd()
PORTS_DIR = path.join(CHCORE_DIR, "ports")
CHPM_DIR = path.join(CHCORE_DIR, ".chpm")
BUILD_DIR = path.join(CHPM_DIR, "build")
DOWNLOADS_DIR = path.join(CHPM_DIR, "downloads")


@dataclass
class File:
    url: str
    name: str
    extract_dir: str
    # sha256: Optional[str] = None # TODO


@dataclass
class RecipeHead:
    name: str
    version: str
    description: str


def read_recipe_head(package_name: str) -> Optional[RecipeHead]:
    recipe_file = path.join(PORTS_DIR, package_name, "recipe.json")
    if not path.isfile(recipe_file):
        return None

    with open(recipe_file, "r", encoding="utf-8") as f:
        recipe_json = json.load(f)

    return RecipeHead(
        name=recipe_json["name"],
        version=recipe_json["version"],
        description=recipe_json["description"],
    )


@dataclass
class Recipe:
    file: str
    target_arch: str
    name: str
    version: str
    description: str
    dependencies: List["Recipe"] = field(default_factory=list)
    source_files: List[File] = field(default_factory=list)
    prebuilt_files: List[File] = field(default_factory=list)
    docker_builder: Optional[str] = None
    working_dir: str = "."
    build: List[str] = field(default_factory=list)
    install: List[str] = field(default_factory=list)
    install_prebuilt: List[str] = field(default_factory=list)


def read_recipe(package_name: str, arch: str) -> Recipe:
    recipe_file = path.join(PORTS_DIR, package_name, "recipe.json")
    if not path.isfile(recipe_file):
        print_err(f"Package `{package_name}` not found")
        exit(1)

    with open(recipe_file, "r", encoding="utf-8") as f:
        recipe_json = json.load(f)

    recipe = Recipe(
        file=recipe_file,
        target_arch=arch,
        name=recipe_json["name"],
        version=recipe_json["version"],
        description=recipe_json["description"],
    )

    def get_arch_aware_list(
        recipe_json: Dict[str, Any], key: str, arch: str
    ) -> List[Any]:
        val = recipe_json.get(key)
        if not val or not isinstance(val, (list, dict)):
            return []
        if isinstance(val, dict):
            return val.get(arch, [])
        return val

    dependencies = get_arch_aware_list(recipe_json, "dependencies", arch)
    for dep in dependencies:
        recipe.dependencies.append(read_recipe(dep, arch))

    def json_to_file(file_json: Dict[str, Any]) -> File:
        return File(
            url=file_json["url"],
            name=file_json["name"],
            extract_dir=file_json["extract_dir"],
        )

    source_files = get_arch_aware_list(recipe_json, "source_files", arch)
    for file in source_files:
        recipe.source_files.append(json_to_file(file))
    prebuilt_files = get_arch_aware_list(recipe_json, "prebuilt_files", arch)
    for file in prebuilt_files:
        recipe.prebuilt_files.append(json_to_file(file))

    recipe.docker_builder = recipe_json.get("docker_builder")
    recipe.working_dir = recipe_json.get("working_dir") or "$CHPM_BUILD_DIR"
    recipe.build = get_arch_aware_list(recipe_json, "build", arch)
    recipe.install = get_arch_aware_list(recipe_json, "install", arch)
    recipe.install_prebuilt = get_arch_aware_list(recipe_json, "install_prebuilt", arch)
    return recipe


def download_file(file: File, downloads_dir: str) -> Optional[str]:
    local_path = path.join(downloads_dir, file.name)
    print_dbg("local_path", local_path)
    if path.exists(local_path):
        print_dbg(f"File `{local_path}` already exists")
    else:
        if subprocess.call(["curl", "-o", local_path, file.url]) != 0:
            if path.isfile(local_path):
                os.remove(local_path)
            return None
    return local_path


def extract_file(file: File, local_file: str, build_dir: str) -> Optional[str]:
    tmp_extract_dir = path.join(build_dir, file.extract_dir + "_tmp")
    extract_dir = path.join(build_dir, file.extract_dir)
    print_dbg("tmp_extract_dir:", tmp_extract_dir)
    print_dbg("extract_dir:", extract_dir)
    os.mkdir(tmp_extract_dir)

    class ZipFileWithPermissions(zipfile.ZipFile):
        def _extract_member(self, member, targetpath, pwd):
            if not isinstance(member, zipfile.ZipInfo):
                member = self.getinfo(member)

            super_extract_member = getattr(super(), "_extract_member")
            targetpath = super_extract_member(member, targetpath, pwd)

            attr = member.external_attr >> 16
            if attr != 0:
                os.chmod(targetpath, attr)
            return targetpath

    def unpack_zip(filename: str, extract_dir: str):
        with ZipFileWithPermissions(filename) as zip:
            zip.extractall(extract_dir)

    shutil.unregister_unpack_format("zip")
    shutil.register_unpack_format("zip", [".zip"], unpack_zip)
    try:
        shutil.unpack_archive(local_file, tmp_extract_dir)
    except Exception:
        shutil.rmtree(tmp_extract_dir)
        return None

    # strip the only subdirectory if any
    subdirs = os.listdir(tmp_extract_dir)
    if len(subdirs) == 1 and subdirs[0] == file.extract_dir:
        shutil.move(path.join(tmp_extract_dir, subdirs[0]), extract_dir)
        shutil.rmtree(tmp_extract_dir)
    else:
        shutil.move(tmp_extract_dir, extract_dir)
    return extract_dir


def download_and_extract_files(
    files: List[File], downloads_dir: str, build_dir: str
) -> bool:
    for file in files:
        local_file = download_file(file, downloads_dir)
        if not local_file:
            print_err("Failed to download source file", file.name, "from", file.url)
            return False
        extract_dir = extract_file(file, local_file, build_dir)
        if not extract_dir:
            print_err(
                "Failed to extract source file",
                file.name,
                "to",
                file.extract_dir,
            )
            return False
    return True


def eval_env_vars(s: str) -> str:
    return subprocess.check_output(["bash", "-c", f'echo -n "{s}"']).decode()


def try_install_recipe(recipe: Recipe, downloads_dir: str, build_dir: str) -> bool:
    os.environ["CHPM_RECIPE_FILE"] = recipe.file
    os.environ["CHPM_RECIPE_DIR"] = path.dirname(recipe.file)
    os.environ["CHPM_PKG_NAME"] = recipe.name
    os.environ["CHPM_PKG_VERSION"] = recipe.version
    os.environ["CHPM_BUILD_DIR"] = build_dir

    for file in recipe.source_files + recipe.prebuilt_files:
        file.url = eval_env_vars(file.url)
        file.name = eval_env_vars(file.name)
        file.extract_dir = eval_env_vars(file.extract_dir)
    recipe.working_dir = eval_env_vars(recipe.working_dir)

    if not download_and_extract_files(recipe.source_files, downloads_dir, build_dir):
        return False
    if not download_and_extract_files(recipe.prebuilt_files, downloads_dir, build_dir):
        return False

    cmd_prefix = []
    if recipe.docker_builder:
        # For packages that should be built in docker container,
        # we prepare a prefix for every build command and install
        # command.
        cmd_prefix.extend(
            [
                "docker",
                "run",
                "-ti",
                "--rm",
                "-u",
                f"{os.getuid()}:{os.getgid()}",
                "-v",
                f"{CHCORE_DIR}:{CHCORE_DIR}",
            ]
        )
        for (env, val) in os.environ.items():
            if env.startswith("CHPM_"):
                cmd_prefix.extend(["-e", f"{env}={val}"])
        cmd_prefix.append(recipe.docker_builder)

    working_dir = recipe.working_dir
    print_dbg("working_dir:", recipe.working_dir)

    print_info("Running build commands...")
    for build_cmd in recipe.build:
        cmd = cmd_prefix + ["bash", "-c", f"cd {working_dir} && " + build_cmd]
        print_dbg("cmd:", cmd)
        ret = subprocess.call(cmd)
        if ret != 0:
            print_err("Failed to run build command")
            return False

    print_info("Running install commands...")
    for install_cmd in recipe.install:
        cmd = cmd_prefix + ["bash", "-c", f"cd {working_dir} && " + install_cmd]
        print_dbg("cmd:", cmd)
        ret = subprocess.call(cmd)
        if ret != 0:
            print_err("Failed to run install command")
            return False

    return True


def install_recipe(recipe: Recipe):
    for dep in recipe.dependencies:
        install_recipe(dep)

    print_info(f"Installing `{recipe.name}`...")

    downloads_dir = path.join(DOWNLOADS_DIR, recipe.name)
    os.makedirs(downloads_dir, exist_ok=True)
    print_dbg("downloads_dir:", downloads_dir)

    build_dir = path.join(BUILD_DIR, recipe.name)
    if path.isdir(build_dir):
        shutil.rmtree(build_dir)
    os.makedirs(build_dir)
    print_dbg("build_dir:", build_dir)

    ok = try_install_recipe(recipe, downloads_dir, build_dir)
    if not ok:
        print_err(f"Failed to install `{recipe.name}`")
    else:
        print_info(f"Successfully installed `{recipe.name}`")

    shutil.rmtree(build_dir)
    if not ok:
        exit(1)


subcommands = {}


def subcommand(name: str):
    def deco(func: Callable) -> Callable:
        subcommands[name] = func
        return func

    return deco


@subcommand("install")
def subcommand_install(args: Namespace):
    arch = args.arch
    prefix = path.abspath(args.prefix)
    os.environ["CHPM_TARGET_ARCH"] = arch
    os.environ["CHPM_TARGET_PREFIX"] = prefix

    for package_name in args.packages:
        recipe = read_recipe(package_name, arch)
        print_dbg("recipe:", recipe)
        install_recipe(recipe)


@subcommand("config")
def subcommand_config(args: Namespace):
    pass


@subcommand("search")
def subcommand_search(args: Namespace):
    keyword = args.keyword
    print_dbg("search keyword:", keyword)

    ports = os.listdir(PORTS_DIR)
    result = []
    for port in ports:
        print_dbg("port:", port)
        if keyword in port:
            result.append(port)
    print_dbg("search result:", result)

    if result:
        print_info("Search result:\n")
    for pkg in result:
        recipe_head = read_recipe_head(pkg)
        assert recipe_head
        print_info(
            f"{recipe_head.name} ({recipe_head.version}):\n\t{recipe_head.description}"
        )


def create_argparser() -> ArgumentParser:
    parser = ArgumentParser(description="The ChCore Package Manager.")
    parser.add_argument(
        "-v",
        "--verbose",
        dest="verbose",
        action="store_true",
        default=False,
        help="Verbose mode",
    )
    subparsers = parser.add_subparsers(dest="subcommand")

    parser_install = subparsers.add_parser("install", help="install package")
    parser_install.add_argument(
        "-p",
        "--prefix",
        dest="prefix",
        required=True,
        help="prefix of install destination",
    )
    parser_install.add_argument(
        "-a", "--arch", dest="arch", help="target architecture", required=True
    )
    parser_install.add_argument("packages", nargs="+", help="packages to install")

    parser_config = subparsers.add_parser("config", help="change config")

    parser_search = subparsers.add_parser("search", help="search for packages")
    parser_search.add_argument("keyword", help="search keyword")

    # TODO: other subcommand

    return parser


def main():
    assert path.isdir(PORTS_DIR)
    os.makedirs(BUILD_DIR, exist_ok=True)
    os.makedirs(DOWNLOADS_DIR, exist_ok=True)

    parser = create_argparser()
    args = parser.parse_args()
    if not args.subcommand:
        parser.print_help()
        exit(1)

    global print_dbg
    if not args.verbose:
        print_dbg = lambda *a, **kw: None

    print_dbg("Command args:", args)
    subcommands[args.subcommand](args)


if __name__ == "__main__":
    main()
